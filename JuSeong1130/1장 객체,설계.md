## 요약 정리


극장이 관람객 가방을 뒤지는건 이상하다 예상이 빗나가게 된다.
그럼 어떻게 해야되냐?
자기할일을 자기가 하면된다. 즉 수동적이던 관람객을 능동적으로 바꾸면된다.
그러면 극장은 관람객의 세부사항을 알필요 없이 티켓만 받을 수 있다.
서로 세부사항을 알지 않으니 결합도가 높아지지 않는다.
자율성을 보장하라

근데 자율성이 높아지는데 불필요한 의존성이 생길 수 있다.
 의존성의 추가는 높은 결합도를 의미하 고, 높은 결합도는 변경하기 어려운 설계를 의미한다.
트레이드오프의 시점이 왔다. 어떤 것을 우선해야 하는가? 자율성보다는 결합도를 낮추는 것이 더 중요할 수 있다.

public class TicketSeller {
	public void sellTo(Audience audience) {
		//ticketOffice.plusAmount(audience.buy(ticketOffice.getTicket())); 
		위방식에서 아래로 바뀌면서 ticketOffice에는 없단 audience 의존성이 생겼다.
		변경 전에는 알지 못했으나 자율성을 위해 변경하면서 새로운 의존성이 추가됬다.
		ticketOffice.sellTicketTo(audience);
	}
}
티켓셀러가 티켓 오피스와 오디언스에 의존하였다면
변경후에는 티켓셀러가 티켓오피스와 오디언스에 의존하고 티켓오피스도 오디언스에 의존하게 된다.

Audience와의 결합도 vs TicketOffice의 자율성
여기서는 티켓셀러가 티켓오피스에 조금더 관연하더라도 즉 자율성을 좀 낮추더라도
오디언스와 의존성 자체가 생기는걸 막는 것 같다.  
의존성이 있는 것은 어쨌든 결합도가 생기는 것이기 때문에
원래 이미 있던 의존성을 조금더 결합시키더라도 티켓 오피스와 오디언스와의 의존성을
끊은것이다.


훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는것이다.

자율성을 높인다 : 서로 세부적인 사항을 각자 객체 내부에 숨긴다. 이걸 캡슐화라고 부르는데 이렇게 캡슐화를 하게 되면 객체와 객체사이의 결합도를 낮출 수 있고 변경에 쉬어진다.
다른 객체가 어떤 객체에 세부적인 사항을 직접적으로 접근하게 되면 결합도가 강해진다.
이는 변경에 있어 좋지 않게 된다.  즉 getAmount를 직접적으로 의존하고 있어 이를 변경하려면 쉽지 않다. 기능 내부적인 구현을 바꿀려고 해도 말이다.

의존성이 제거 된다 : 불필요한 결합도가 제거 된다.

설계를 어렵게 만드는것은 의존성이라는 것을 기억하라.
해결방법은 불필요한 의존성을 제거함으로써 객체사이의 결합도를 낮추는것이다.







---

## 소프트웨어 목적

```
모든 소프트웨어 모듈에는 세가지목적이있다
1. 실행중에 제대로 동작하는것
2. 변경을 위해 존재하는것 : 모든 소프트웨어는 변경된다.
3. 코드를 읽는 사람과 의사소통하는것 : 특별한 훈련없이도 개발자가 쉽게 읽고 이해할 수 있어야한다.
```
## 예상을 빗나가는 코드
```
소극장은 관람객의 가방을 열어 그 안에 초대장이 들어있는지 확인한다. (getter를 이용)
```
소극장이 관람객의 가방을 열어보는게 예상이 가는 코드일까?

**이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드이다.**
위에서 설명한것은 우리가 예상한 동작과 많이 벗어나게 된다.

관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는것이 문제이다.
관람객과 판매원은 자기가 할 수 있는일임에도 불구하고 소극장이 모든일을 진행한다.

현실에서는 관람객이 직접 능동적으로 초대권이든 돈을 꺼내 판매원에게 넘긴다.
판매원은 이를 확인해 관람객에서 티켓을 전달한다.
소극장은 티켓을 확인하고 입장만 시킬뿐이다.

또한 코드를 이해하기 어렵게 만드는 또 다른 이유가 있는데 코드를 이해하기 위해서는 세부적인 내용들을 한꺼번에 기억하고 있어야한다는 점이다.

한 코드에 너무 많은 세부사항을 작성하면 작성하는 사람뿐만아니라 코드를 읽고 이해해야하는 사람 모두에게 큰 부담을 준다. > 그래서 세부사항을 각 클래스에게 메시지를 보내고 위임하는거 같다

## 설계 개선하기

변경과 의사소통이라는 문제가 서로 엮여 잇다는 점에 주목하라
코드를 이해하기 어려운 이유는 Theater 가 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다.

이것은 관람객과 판매원이 자신의 일을 스스로 처리해야한다는 우리의 직관을 벗어난다.
다시말해서 의도를 정확하게 의사소통하지 못하기 때문에 코드가 어려워진 것이다.

Theater가 관람객 가방과 판매원 매표소에 직접 접근한다는것은 Theater 와 관람객과 판매원이 결합됬다는것을 의미한다.
따라서 관람객과 판매원 을 변경할때 극장도 함께 변경되어야하기 때문에 전체적으로 코드를 변경하기도 어려워진다.

방법은 간단하다. 서로가 너무 세세한 부분까지 알지못하도록 정보를 차단하면된다.
관람객이 가방을 가지고 있다는 사실과 판매원이 매표소에서 티켓을판매한다는 사실을 Theater가 알아야할 필요가 없다.

**객체는 스스로의 일을 자기가알아서 능동적으로 처리하는 자율적인 존재가 되면된다.**


## 절차지향과 객체지향
```
수정하기 전의 코드에서는 Theater의 enter 메서드 안에서 Audience와 TicketSeller로부터 Bag
과 TicketOffice를 가져와 관람객을 입장시키는 절차를 구현했다. Audience, TicketSeller, Bag, TicketOffice는 관람객을 입장시키는 데 필요한 정보를 제공하고 모든 처리는 Theater의 enter 메서드 안에 존재했었다는 점에 주목하라.
이 관점에서 Theater의 enter 메서드는 프로세스(Process)이며 Audience, TicketSeller, Bag, TicketOffice는 데이터(Data)다. 이처럼 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차 적 프로그래밍(Procedural Programming)이라고 부른다.
```
절차지향은 프로세스에 다른 데이터를 넣어 절차적으로 처리하는것이다.
모든 처리가 하나의 클래스안에 위치하고 나머지 클래스는 단지 데이터의 역할만 수행하게 된다.

절차지향은 코드를 읽는것을 힘들게 만들고 이는 의사소통을 제대로 하지 못하게 된다.
또한 변경에 있어 지역적으로 고립시키기 어렵다.

그럼 객체지향은?
데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍 하는 방식을 객체지향 프로그래밍이라고 부른다.

객체지향이 좋은것 같지만 절차지향에서 객체지향으로 바꾸면서 A라는 객체에 B라는 의존성이 없었지만 생기게 되는 경우도 있다. 모든것은 트레이드 오프다.
단 객체지향에서는 하나의 변경으로 인한 여파가 여러클래스로 전파되는것을 효율적으로 억제한다.
이말은 즉 전파되는것은 있을 수 있으나 효율적으로 관리할 수 있다는 뜻 같다.

## 더 개선할 수 있다.
```
public class TicketSeller {
	public void sellTo(Audience audience) {
		ticketOffice.sellTicketTo(audience);
	}
}
```
만족스러운가? 안타깝게도 이 변경은 처음에 생각했던 것만큼 만족스럽지 않다. 그 이유는 TicketOffice와 Audience 사이에 의존성이 추가됐기 때문이다. 변경 전에는 TicketOffice가 Audience에 대해 알지 못했었다는 사실을 기억하라. 변경 후에는 TicketOffice가 Audience에게 직접 티켓을 판매하 기 때문에 Audience에 관해 알고 있어야 한다.
변경 전에는 존재하지 않았던 새로운 의존성이 추가된 것이다. 의존성의 추가는 높은 결합도를 의미하 고, 높은 결합도는 변경하기 어려운 설계를 의미한다. TicketSeller의 자율성은 높였지만 전체 설계의 관점에서는 결합도가 상승했다. 어떻게 할 것인가?

현재로서는 Audience에 대한 결합도와 TicketOffice의 자율성 모두를 만족시키는 방법이 잘 떠오르지않는다. 트레이드오프의 시점이 왔다. 어떤 것을 우선해야 하는가? 토론 끝에 개발팀은 TicketOffice의 자율성보다는 Audience에 대한 결합도를 낮추는 것이 더 중요하다는 결론에 도달했다.

