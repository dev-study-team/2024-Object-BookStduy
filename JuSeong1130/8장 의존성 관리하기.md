협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠트릴 수 있다. 협력은 객체가 다른 객체에 대해 알 것을 강요한다.

다른 객체와 협력하기 위해서는 그 객체가 존재해야한다는것을 알아야하며, 수신할 수 있는 메시지에 대해서도 알고 있어야한다. 이런 지식이 객체 사이의 의존성을 낳는다.

협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다.
객체 지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다.

이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다.

6장에서 말한 getter와 상황이 비슷한거 같다.

⭐ 의존성을 어떻게 유연하게 할까?
1. 컴파일 타임 의존성과 런타임 의존성을 분리해라! 
컴파일 타임에 구체 클래스에 의존하게 되면 구체 클래스에 의존하여 다양한 협력을 적용하지 못한다. 그래서 추상 클래스인 인터페이스에 의존하여 결합도를 낮추고 다양한 협력을 할 수 있게 하는것

컴파일 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다. 

협력을 결정하고 협력에 필요한 책임을 수행하기 위해서 어떤 객체가 필요한지 고민하고 그 책임이 다양한 방식으로 추상화 될때 타입 계층 안 절차를 추상화 해야 한다.

2. 컨텍스트는 독립적이어야 한다. 
컨텍스트가 독립적이라는 말은 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미이다. 

클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다. 구체적인 클래스를 알면 알수록 그 클래스가 사용하는 특정한 문맥에 `강하게 결합되기 떄문`이다.

다르게 말하면 설계가 유연해지기 위해서는 가능한 실행될 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야한다. 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될수 있기 떄문이다.

클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해지며 이를 **컨텍스트 독립성**이라 부른다.
ex) 할인 조건  vs 주말 할인조건  : 주말할인조건은 주말이라는 문맥이 고정되버린다.


3. 의존성 해결
컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.

- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter로 의존성 해결 : Movie 인스턴스가 생성 된 후에도 설정 가능 단 그전까지 값이 들어있지 않다는 불안정한 단점 존재, 이런 단점 해결하기 위해 생성자와 setter 방식 혼합가능 
- 메서드 실행시 매개변수로 의존성 해결 : Movie가 항상 할인정책을 알 필요가 없고 가격을 계산할때만 일시적으로 알아도 무방하다면 메서드 인자를 이용해 의존성을 해결할 수 있음, 

메서드 인자를 사용하는 방식은 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실 행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나, 메서드가 실행될 때마다 의존 대상이 매 번 달라져야 하는 경우에 유용하다. 

하지만 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다면 생성자를 이용하는 방식이나 setter 메서드를 이용해 의존성을 지속적 으로 유지하는 방식으로 변경하는 것이 좋다.


⭐ 의존성을 관리하는데 유용한 원칙과 기법

객체지향 패러다임은 협력이 중요하다. 협력하기 위해서는 서로의 존재와 수행가능한 책임을 알아야한다. 이런 지식들이 의존성을 낳는다 그럼 이 의존성이 나쁘냐? 나쁘지 않다. 협력을 가능하게 하는 의존성이라는 매개체라는 관점에서 바람직하다.

하지만 의존성이 과하면 문제가 될 수 있다.

1. 구체적인 클래스에 의존하지마라 추상화에 의존하라
2. 의존성을 명시적으로 드러내라 (setter, 생성자, 메서드인자) 명시적으로 드러내지 않을때 커다란 문제는 의존성이 명시적이지 않으면 `클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다는 것이다`
3. new는 해롭다! new는 불필요한 결합도를 급격하게 높힌다.
new 를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다.
- new를 사용하기 위해서는 구체클래스의 이름을 직접 기술해야한다. 즉 구체 클래스에 의존하므로 결합도가 상승한다.
- new를 사용하면 어떤 인자를 이용해 생성해야하는지를 알아야하므로 클라이언트가 알아야하는 지식의 양이 늘어나기때문에 결합도가 늘어난다. (생성하는데 어떤 정보가 필요한지에 대해서 알아야함)
해결방법은?  
인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하느 것이다.

단 가끔은 생성해도 무방하다. 특별한경우 90퍼센트이상 A클래스에 의존하고 나머지 10% 다른것들일때말이다. 오버로딩을 통해 내부 메서드를 사용하는 방식을 통해 사용한다. 입력 +구체클래스 들어간 오버로딩 , 모두입력받는 오버로딩

결합도와 사용성에 관점에서 구체클래스에 의존하더라도 클래스 사용성이 더 중요하다면 결합도를 높이는 방향으로 작성할 수 있다.

종종 모든 결합도가 모이는 새로운 클래스를 추가함으로써 사용성과 유연성이라는 두 마리 토끼를 잡을 수 있는 경우도 있다. 바로 FACTORY

아 그리고 표준 클래스에 대한 의존은 해롭지않다! array list나 이런것들 말이다.
의존하는게 좋지 않은 이유는 변경인데 표준 클래스 바뀔 확률 0에 수렴하므로 직접 생성하더라도 문제가 되지 않기 떄문이다.

⭐ 위와 같은 원칙을 통해 컨텍스트 확장 가능하다!

설계를 유연하게 만들 수 있던 이유
1. DiscountPolicy라는 추상화에 의존
2. 생성자를 통해서 의존성을 명시적으로 드러냄
3. new와 같이 구체 클래스를 다뤄야하는 걸 외부로 옮김

결합도를 낮춤으로써 얻게되는 컨텍스트의 확장이라는 개념이 유연하고 재사용 가능한 설계를 만드는 핵심이다.

컨텍스트 확장 : 할인정책에서 퍼센트만있더라도 새로운 요구사항이 생기면 확장할 수 있다.



---


협력은 필수적이지만 과도한 협력은 설계를 곤경게 빠트릴 수 있다. 협력은 객체가 다른 객체에 대해 알 것을 강요한다.

다른 객체와 협력하기 위해서는 그 객체가 존재해야한다는것을 알아야하며, 수신할 수 있는 메시지에 대해서도 알고 있어야한다. 이런 지식이 객체 사이의 의존성을 낳는다.

협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다.
객체 지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다.

이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다.

## 컨텍스트 독립성

클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다. 구체적인 클래스를 알면 알수록 그 클래스가 사용하는 특정한 문맥에 `강하게 결합되기 떄문`이다.

7장에 나온 내용에서 기능분해에서 문맥에 결합되는문제가 무엇인지 잘 이해가 가지 않았는데 여기 해답이 있었다.

구체 클래스에 대해 의존하는 것은 클래스의 인스턴스가 어떤 문맥에서 사용될것인지를 구체적으로 명시하는거와 같다.

즉 유연하게 동적으로 바뀌지 못하고 그 문맥안에서만 돌아간다는 뜻이다.
예를들어 할인정책에 적용된다와 기간할인정책에 적용된다 두가지가 있을떄 기간할인정책에 의존하게 되면 기간할인정책에서만 기능이 돌아가게된다. 나머지는 허용이되지 않는다.
그래서 컴파일 타임 의존성과 런타임 의존성을 분리해야한다는것이다.

클래스가 특정한 문맥에 강하게 결합되면 다른 문맥에서 사용하기는 어려워진다.  
클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해지며 이를 **컨텍스트 독립성**이라 부른다.

## 의존성은 나쁘지 않다. 바람직하지 못한 의존성이 문제다

객체지향 패러다임은 협력이 중요하다. 협력하기 위해서는 서로의 존재와 수행가능한 책임을 알아야한다. 이런 지식들이 의존성을 낳는다 그럼 이 의존성이 나쁘냐? 나쁘지 않다. 협력을 가능하게 하는 의존성이라는 매개체라는 관점에서 바람직하다.

하지만 의존성이 과하면 문제가 될 수 있다.

그렇다면 바람직한 의존성이란 무엇인가? 바람직한 의존성은 재사용성과 관련이 있다.
어떤 의존성이 특정한 문맥에 결합되어 재사용할 수 없다면 바람직하지 않은 의존성이다. 특정한 컨텍스트에 강하게 의존하는 클래스를 다른 컨텍스트에서 재사용할 수 있는 유일한 방법은 구현을 변경하는것 뿐이다. 즉 Percent에서 Amount로 구현을 변경하는것 이렇게하면 Amount만 이용가능하며 Amount에 의존하게 된다.

## 명시적인 의존성
의존성은 명시적이어야 한다.

의존성이 명시적이지 않으면 의존성을 파악하기 위해 내부 구현을 직접 살펴볼 수밖에 없다. 커다란 클 래스에 정의된 긴 메서드 내부 어딘가에서 인스턴스를 생성하는 코드를 파악하는 것은 쉽지 않을뿐더 러 심지어 고통스러울 수도 있다.

`더 커다란 문제는 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구 현을 직접 변경해야 한다는 것이다.` 코드 수정은 언제나 잠재적으로 버그의 발생 가능성을 내포한다. 의존성을 명시적으로 드러내면 코드를 직접 수정해야 하는 위험을 피할 수 있다. 실행 컨텍스트에 적절 한 의존성을 선택할 수 있기 때문이다.

의존성은 명시적으로 표현돼야 한다. 의존성을 구현 내부에 숨겨두지 마라. 유연하고 재사용 가능한 설 계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다. `명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.`

클래스가 다른 클래스에 의존하는 것은 부끄러운 일이 아니다. 의존성은 다른 객체와의 협력을 가능하 게 해주기 때문에 바람직한 것이다. 경계해야 할 것은 의존성 자체가 아니라 의존성을 감추는 것이다. 숨겨져 있는 의존성을 밝은 곳으로 드러내서 널리 알려라. 그렇게 하면 설계가 유연하고 재사용 가능해 질 것이다.


## 유연하게 만들자
설계를 유연하게 만들 수 있던 이유
1. DiscountPolicy라는 추상화에 의존
2. 생성자를 통해서 의존성을 명시적으로 드러냄
3. new와 같이 구체 클래스를 다뤄야하는 걸 외부로 옮김
