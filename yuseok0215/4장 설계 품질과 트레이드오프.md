**응집도**
- 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 
- 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.

**결합도**
- 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다.
- 객체지향의 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.

응집도와 결합도를 변경의 관점에서 바라보는 것은 설계에 대한 시각을 크게 변화시킬 것이다.
다만, 응집도와 결합도를 고려하기 전에 먼저 캡슐화를 향상시키기 위해 노력하자.

**스스로 자신의 데이터를 책임지는 객체**
우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다.
객체는 단순한 데이터 제공자가 아니다.
객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.

**데이터 중심 설계**
- "이 객체가 포함해야 하는 데이터가 무엇인가?"
- 설계를 시작하는 너무 이른 시기에 내부 구현에 초점을 맞추게 된다.
- 캡슐화를 위해 속성을 private으로 접근 제어했지만 결국 접근자와 수정자에 의해 public한 속성과 다를바가 없게 된다.

올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다. 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는가는 부가적인 문제다. 중요한 것은 객체가 다른 객체와 협력하는 방법이다.

데이터 중심 설계는 초점이 내부로 향한다. 결국 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 억지로 끼워 맞출 수 밖에 없다.

public methodName(int property1, int property2) { 
    A.calculate(property1, property2)
}

두번째 설계에서 또한 두가지 속성이 해당 클래스에 존재한다는 것을 외부로 알리는 셈이다. 그럼 외부로 알리지 않는 경우는 어떻게 될까?

public methodName(ClassName className) {
  A.calculate(className)
}

이렇게 클래스에게 아예 위임을 해서 결과값만 반환시켜주면 책임을 가지는 객체에서 내부적으로 수행후에 메세지에 대한 답변만 협력하는 객체에게 전달할 수 있게 된다.

