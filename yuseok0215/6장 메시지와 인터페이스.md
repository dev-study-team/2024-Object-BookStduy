퍼블릭 인터페이스: 객체가 의사송통을 위해 외부에 공개하는 메시지의 집합

**디미터 법칙**: 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라.
- 객체 A 와 B가 결합되어있을 때 A의 구조를 변경했을 때 B의 구조가 변경되지 않도록 약한 결합도를 유지해야 한다.
- 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한해야 한다.

**묻지 말고 시켜라**
- 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다.
- 상태를 물어봐서 가져온다면 그 객체와 강한 결합도를 형성하게 된다.

위 두가지 원칙을 이용하여 훌륭한 인터페이스를 제공하기 위해 포함해야 하는 오퍼레이션에 대한 고민을 해보는 것이 좋다.
혹여나 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하는가? -> 해당 객체가 책임져야 하는 행동이 외부로 누수되었을 가능성이 높다.

**의도를 드러내는 인터페이스**
- 메서드의 이름을 짓는 방법은 '어떻게'가 아니라 '무엇을' 하는지를 드러내는 것이다.                  
- 내부 정보까지 메서드의 이름에 표현하게 되면 변경할 때 수정해야 하는 범위가 늘어나게 된다.
- 무엇을 하는지까지만 메서드의 이름에 표현하려 하자.
- 클라이언트가 메서드명을 보았을 때 이해하기 쉬운 이름인가?

**원칙의 함정**
맹목적으로 '묻지 말고 시켜라'와 '디미터 법칙'을 준수하는 것이 항상 긍정적인 결과만을 가져다 주는 것은 아니다. 모든 상황에서 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들이 공존하게 된다. 결과적으로 객체는 상관 없는 책임들을 한꺼번에 떠안게 되기 때문에 결과적으로 응집도가 낮아진다.
클래스는 하나의 변경 원인만을 가져야 한다. 서로 상관 없는 책임들이 뭉쳐있으면 응집도가 낮으며 작은 변경에도 수정 범위가 넓어질 수 있다.

**명령-쿼리 분리 원칙**
- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
- 두 가지가 한 메서드 내부에 공존하게 되면 예상치 못한 버그에 고생할 수 있다.
- 명령과 쿼리를 분리함으로써 참조 투명성을 얻을 수 있다. -> 버그가 적고, 디버깅에 용이하며, 쿼리의 순서에 따라 실행 결과가 변하지 않는 코드를 작성할 수 있다.
